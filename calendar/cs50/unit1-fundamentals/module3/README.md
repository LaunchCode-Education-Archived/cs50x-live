[Back to Course Calendar](../../..)
# Module 3

**Pre-reqs:** You should have completed [Module 2](../module2)

#### Synopsis 

In this module you will be introduced to the methods by which computer scientists analyze the efficiency of algorithms. "Efficient" just means "fast", but a certain kind of fast. Specifically, an algorithm is deemed more efficient than another if it performs better for **very large** inputs; its performance on smaller inputs is not important. You will learn about "asymtotic analysis", a method for classifying algorithms based on how their performance changes as the size of their inputs grows. 

If all that sounds a little intense, well, it is! But you won't be required to carry out a lot of asymtotic analysis yourself; you'll just need to get the hang of the basic idea. The running example throughout the module will be a comparison between a handful of different "sorting" algorithms, which, given a jumbled list of things, sorts the list into order as quickly as possible. You will implement one of these algorithms yourself in Problem Set 3.

We will also spend some time reviewing concepts from Modules 1 and 2, so you continue getting comfortable with the fundamentals of C syntax.

*** 

### Steps

Class # | Date | Before Class | During Class | Topics / Skills
:--------:|:-----:|:--------------:|:--------------:|----------------
Class 1 | *TBD* | [Prep Work](./materials/class1-prep) | [In Class](./materials/class1) | sorting algorithms, time complexity analysis, module1 review, more practice with functions
Class 2 | *TBD* | [Prep Work](./materials/class2-prep) | [In Class](./materials/class2) | recursion, merge sort, module2 review, more debugging, compiling, multiple files working together
Class 3 | *TBD* | Work on [Pset3](./materials/problem-set) | [In Class](./materials/class3) | (office hours)

